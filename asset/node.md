- Spring Boot3版本只支持knife4j的openapi3
- 在配置邮件服务的时候,如果配置文件写在dev上,会导致无法进行自动装配
- 循环依赖通过setter解决
- 启动时可以通过启动类的exclude去掉依赖的自动装配
- 日期格式,可以使用@JsonFormat(针对单一属性)WebMvcConfiguration扩展消息转换器(同一转换)
- 无感token刷新:纯后端(由服务器来刷新token,但是需要前端发送请求才能感知);
  前后协同(通过access-token和refresh-token实现前端定时检查token,比较安全).
  为了提高用户的体验,前端应该做一个草稿箱的功能防止过期刷新带来差的体验
- 由于项目比较简单不需要分区多种角色(用api端点),同时由于用户需要在班级中进行区分,
  因此权限管理在此项目中通过业务前进行区分(通过注解进行灵活的配置)
  项目中由于多个角色共用接口,带来了一定的权限管理复杂度
- 部署计算函数遇到很多坑:文档指引不全或者文档没有及时更新,计算函数demo创建的服务和OSS不在一个域导致access deny;
- STS和OSS下载设计权限等,在测试的时候cli又和文档不一样,有时候是自己的问题,有时候又是文档不一致导致的
- 碰到循环依赖,除了setter、懒加载,还可以通过调整业务状态来避免出现循环依赖的情况
- 进行社交登录时候,认证服务器会保留一个重定向的url,而浏览器参数中也会带有重定向url,如果这两个url不一样在登录认证的时候会出现问题
- 在阿里云服务器上折腾了frp没弄成,不如使用花生壳等内网穿透工具简单好用(但是这些软件需要实名认证很烦)
  一直无法通过原因在于www.example.name是要填写真实的域名,我没有域名,在域名里面直接填写ip地址就可以了!!!
- 循环依赖的解决方式:(https://cloud.tencent.com/developer/article/2313254)
    - 1.调整业务代码,避免循环依赖
    - 2.通过setter注入(同时需要在配置中打开循序循坏依赖否则注入还是失败)
    - 3.懒加载(通过@Lazy注解在构造的时候注入代理,等到调用的时候再进行初始化)
    - 4.@PostConstruct+@Autowired(通过@PostConstruct注解在构造完成后进行初始化,需要结合setter)
    - 其中一个很有意思的在于A和B相互依赖的前提下,
      A中注入B采用setter，B中注入A采用构造器是可以的;A中注入B采用构造器，B中注入A采用setter是不可以的
- 由于作业提交的接口classId是存放在请求体里面的,因此拦截器没办法获取到classId,而切面进行权限检查又需要classId,因此放弃对这个接口注解权限检查采用手动检查的方式
- 将未来很久的延迟消息进行数据库持久化,配合定时任务减少队列的解压
- 在进行回调的时候出现了理解的混乱,认为回调是在服务器端进行的,实际上是在客户端进行的.服务器只是设置了一些参数,实际上回调是前端进行的.
  后端是被动的不是主动的;而且在自定义参数上一直没有办法成功进行回调获取!!!
- 作业打包在OSS实现的时候,预期是返回打包文件的地址,然后生成STS临时token给用户自行获取,但是在实际中发现OSS打包返回的访问地址已经是通过url签名的因此可以直接访问下载的.
  鉴于目前的要求使用签名url就足够了,因此放弃使用sts
- Mybatis-plus中select方法传入的是一个数组,如果需要多个字段多次使用select会导致前面的select被覆盖最终差不出完整的属性值
- 接口幂等的后端实现方案:主键索引+全局唯一ID,数据库锁,token防重令牌,唯一索引,防重表,分布式锁,限流次数为1等等;
- 接口幂等的前端实现方案:按钮限制,时间戳+签名等等