- Spring Boot3版本只支持knife4j的openapi3
- 在配置邮件服务的时候,如果配置文件写在dev上,会导致无法进行自动装配
- 循环依赖通过setter解决
- 启动时可以通过启动类的exclude去掉依赖的自动装配
- 日期格式,可以使用@JsonFormat(针对单一属性)WebMvcConfiguration扩展消息转换器(同一转换)
- 无感token刷新:纯后端(由服务器来刷新token,但是需要前端发送请求才能感知);
  前后协同(通过access-token和refresh-token实现前端定时检查token,比较安全).
  为了提高用户的体验,前端应该做一个草稿箱的功能防止过期刷新带来差的体验
- 由于项目比较简单不需要分区多种角色(用api端点),同时由于用户需要在班级中进行区分,
  因此权限管理在此项目中通过业务前进行区分(通过注解进行灵活的配置)
  项目中由于多个角色共用接口,带来了一定的权限管理复杂度
- 部署计算函数遇到很多坑:文档指引不全或者文档没有及时更新,计算函数demo创建的服务和OSS不在一个域导致access deny;
- STS和OSS下载设计权限等,在测试的时候cli又和文档不一样,有时候是自己的问题,有时候又是文档不一致导致的
- 碰到循环依赖,除了setter、懒加载,还可以通过调整业务状态来避免出现循环依赖的情况
- 进行社交登录时候,认证服务器会保留一个重定向的url,而浏览器参数中也会带有重定向url,如果这两个url不一样在登录认证的时候会出现问题
- 在阿里云服务器上折腾了frp没弄成,不如使用花生壳等内网穿透工具简单好用(但是这些软件需要实名认证很烦)
  一直无法通过原因在于www.example.name是要填写真实的域名,我没有域名,在域名里面直接填写ip地址就可以了!!!
- 循环依赖的解决方式:(https://cloud.tencent.com/developer/article/2313254)
    - 1.调整业务代码,避免循环依赖
    - 2.通过setter注入(同时需要在配置中打开循序循坏依赖否则注入还是失败)
    - 3.懒加载(通过@Lazy注解在构造的时候注入代理,等到调用的时候再进行初始化)
    - 4.@PostConstruct+@Autowired(通过@PostConstruct注解在构造完成后进行初始化,需要结合setter)
    - 其中一个很有意思的在于A和B相互依赖的前提下,
      A中注入B采用setter，B中注入A采用构造器是可以的;A中注入B采用构造器，B中注入A采用setter是不可以的
- 由于作业提交的接口classId是存放在请求体里面的,因此拦截器没办法获取到classId,而切面进行权限检查又需要classId,因此放弃对这个接口注解权限检查采用手动检查的方式
- 将未来很久的延迟消息进行数据库持久化,配合定时任务减少队列的解压
- 在进行回调的时候出现了理解的混乱,认为回调是在服务器端进行的,实际上是在客户端进行的.服务器只是设置了一些参数,实际上回调是前端进行的.
  后端是被动的不是主动的;而且在自定义参数上一直没有办法成功进行回调获取!!!
- 作业打包在OSS实现的时候,预期是返回打包文件的地址,然后生成STS临时token给用户自行获取,但是在实际中发现OSS打包返回的访问地址已经是通过url签名的因此可以直接访问下载的.
  鉴于目前的要求使用签名url就足够了,因此放弃使用sts
- Mybatis-plus中select方法传入的是一个数组,如果需要多个字段多次使用select会导致前面的select被覆盖最终差不出完整的属性值
- 接口幂等的后端实现方案:主键索引+全局唯一ID,数据库锁,token防重令牌,唯一索引,防重表,分布式锁,限流次数为1等等;
- 接口幂等的前端实现方案:按钮限制,时间戳+签名等等
- lua脚本中KEYS和ARVG的区别在于集群环境下可能会使用KEYS进行分片,如果混用的话在集群环境下可能会出现一些问题
  - redisTemplate.execute(redisScript, List.of(key), idempotentToken)
    代码对第三个参数进行了List封装导致一直返回0,这是继Mybatis连续调用select()之后又重复犯的错,没有看清楚参数类型
  - 在lua脚本执行失败的期间,在redis cli进行脚本调试发现redis.call()
    返回的类型和redis原生的类型不一致导致一直没办法通过调试,在编程语言中可以通过,这个还没有深入了解协议如何处理类型的不同
- 开启生产者确认模式,在发送消息的时候,如果发送失败,会返回一个错误的消息,可以通过这个消息进行重试.包含了confirmCallback和returnCallback
- 对于消费者来说,开启了手动ack的模式后,如果消息没有手动ack会进入Unacked状态,消费者关闭之后会重新变成ready状态,容易导致重复消费
- 先处理业务再进行确认,可以避免消息丢失但是可能出现重复消息,可以采用唯一性标识、幂等性处理和消息去重等手段来保证消息不被重复消费或者避免重复消费的影响
- 发送消息到队列时correlationId需要设置两次,在CorrelationData设置的只能在生产端看到,在消费者端看不到,因此在message
  lambda表达式中多设置一次相同的值方便两端消息定位
- 由于缓存设计的原因,有一些接口使用缓存可能会有更大的代价,比如带宽之类的,因此有部分相关的查询接口不使用缓存进行加速
- 班级中用户的权限管理,采用先删缓存再改数据库,然后使用分布式锁来保证数据的一致性
- 班级信息的修改一致性要求不高,因此采用比较宽松的方式来保证数据的一致性,比如先改数据库再删缓存配合延迟双删,删除操作可以采用加锁的方式